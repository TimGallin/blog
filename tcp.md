##Transmission Control Protocol##
>TCP(Transmission Control Protocal)
>可靠的按序递交的传输特性

###TCP的出现###
越复杂越容易出错，而互联网正是一种十分复杂的结构。TCP正是为了应对互联网络各种故障的设计。

###TCP报文结构###
>Segment structure

```
    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |          Source Port          |       Destination Port        |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                        Sequence Number                        |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                    Acknowledgment Number                      |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |  Data |           |U|A|P|R|S|F|                               |
   | Offset| Reserved  |R|C|S|S|Y|I|            Window             |
   |       |           |G|K|H|T|N|N|                               |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |           Checksum            |         Urgent Pointer        |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                    Options                    |    Padding    |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                             data                              |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
```
**Source Port:**
源端口

**Destination Port:**
目标端口

**Sequence Number:**
序列号
TCP协议的一个基础概念就是在TCP中对每一个data端的每一个8位字节都有一个编号。例如，在SYN为0的情况下，如果此时SEQ为x，则代表data段中的第一个字节编号为x。如果该data段具有100个字节，则data段的编号范围为x~x+100。而如果在SYN为1时，即在链接建立阶段，此时SEQ为ISN（Initial Sequence Number，初始序列号为一个有效范围内的随机数）,第一个字节的序号为x+1，即ISN+1。
需要明确的是，序列号是有范围的，在协议中规定，序列号的有效范围是0~2^32 -1。当序列号到达边界时将重置为0。

**Acknowledgment Number:**
确认号
当ACK为1时，确认号代表下一个期待收到的序列号。例如上一个收到的数据段的序列号为x，则此时恢复的数据段的确认号就是x+1。而当发送端收到该确认号时，即可确认上一个数据段已成功送达。
ACK只有在第一个SYN数据段发送时被置位0，在链接建立后将一直为1。

**Data Offset:**
数据段的开始位置。这主要时由于Option段时变长的。如果Option段有两个32bit大小，则DataOffset就是7

**Reserved:**
保留6个bit

**URG**
Urgent。紧急数据标志位。当为1时代表接收端接收到这个数据段后应该立即交给应用程序处理而不是缓冲起来等到缓冲区满再通知应用程序

**ACK**
确认标志。除了在第一个SYN数据段为0，其他时候都为1

**PSH**
PUSH。为1时发送端应该立即把该数据段发出，而不是缓冲起来等到缓冲区满再发送

**RST**
重置（RESET）。通常在服务端积极拒绝或者双方关闭链接时RST为1。

**SYN**
同步（Synchronize ）。用于链接建立时的数据段标志

**FIN**
同步（FINAL ）。示意链接关闭

**Window**
用于滑动窗口的处理，标志了从确认号开始，这个TCP段发送者下一次愿意接收的数据段大小。

**CheckSum**
校验和

**Urgent Pointer**
Urgent信息

**Option**
Option可能在TCP头部的结尾占多个8bit单位的长度。所有的option都包含在checksum中。

校验和

###TCP的服务模型###
>**套接字**

端与端之间通过创建套接字来进行信息传输。每一个套接字都具有一个由端的IP地址和该套接字所绑定的端口号构成的编号。套接字之间具有一对多的特性。

>**全双工特性**

端与端之间可以同时发送数据。



>**TCP链接的建立**
>Three-Way hand shake（三次握手）

```
	|  SYN(SEQ=ISN_X,ack(off))       |
	|------------------------------->|
	|                                |
	|  SYN(SEQ=ISN_Y,ACK=ISN_X+1)    |			
	|<-------------------------------|
	|                                |
	|  SYN(SEQ=ISN_X+1,ACK=ISN_Y+1)) |	  
	|------------------------------->|
```
以接收端与发送端为例。发送端首先向接收端发起建立连接的请求，接收端接收到请求后向发送端回复确认消息，发送端再向接收端发送确认消息，至此三次握手完毕，TCP建立完成。

>**TCP链接的释放**
>Three-Way hand shake（三次握手）

```
	|  SEQ=X,FIN(ON)                 |(TIMER，timeot=2*max_package_time)
	|------------------------------->|
	|                                |
	|  SEQ=Y,ACK=X+1,FIN(ON)         |			
	|<-------------------------------|(TIMER，timeot=2*max_package_time)
	|                                |
	|  SEQ=X+1,ACK=Y+1               |	  
	|------------------------------->|
```

以发送端为例，发送端发送一个FIN为1的TCP段，同时开启一个一般超时为2倍最大数据包的生存周期。当在超时时间内没有收到回复确认消息，则直接断开连接。而当接收端收到FIN断开消息时，这一端同一样也回复一个断开消息同时确认另一端发送过来的断开消息。当发送端收到断开确认消息后，在回复一个确认消息后即可断开连接，而在接收端接收到断开确认后，也可以完成断开。至此TCP断开完毕。由于双方都有定时器的保障，这避免了网络传输问题而导致数据送达不及时或丢失造成的一些问题。

###Round-trip Delay Time(RTD)###
>**RTD**（Round-trip Delay Time）或**RTT**（Round-trip Time）是指一个信号发出的时间开始知道接收到这个信息的确认消息之间所消耗的时间。通常我们使用PING命令得到时间就是RTT。

RTD与TCP的重传计时器相关，试想当发送端发送一个TCP段后在一段时间内没有收到确认信息，则可以认为这段数据包已经丢失，需要重传。问题是如何设定这段超时时间，无论过短或过长都会影响到TCP的效率与使用。TCP采用动态算法，他根据网络性能的波动来确认一个变化的超时时长。

###Sliding window protocol(滑动窗口协议)###
>滑动窗口协议主要是为了解决由于不合理的数据包大小、双方应用程序对数据缓冲区的读写速度差异造成的性能损失
>滑动窗口协议是基于数据包的数据传输协议的一种特质。

Window(窗口)具有16位bit大小最大为2^16-1(**64KB**)的整数，它代表着从确认号开始，这个TCP段发送者下一次愿意接收的数据段大小。
当TCP的一端向另一端发送远远大于它能处理缓冲的数据包时，这会导致由缓冲区溢出造成的丢包。假设双方能知道对方此时能处理的数据包大小就可以有效避免这种问题，而窗口正是对于这种特性的形象描述，双方通过窗口字段明确对方此时可以接收的数据包大小就像通过一扇窗户一样知悉对方的情况。
假设接收端的缓冲区大小为4096字节。此时发送端发送了一个1KB大小的数据包，接收端接收到这个数据包后，在应用程序将这部分数据读出之前，缓冲区将剩下3KB的有效缓冲空间，这是接收端回复给发送端的确认消息就应该是WIN=3072（3KB）。

```
	|  SEQ=X,SIZE=1KB                |
	|------------------------------->|
	|                                |
	|  SEQ=Y,ACK=X+1025,WIN=3072     |			
	|<-------------------------------|
	|  SEQ=Y,ACK=X+1025,WIN=4096     |应用程序读出1KB，发送一个窗口更新段			
	|<-------------------------------|
```

>TCP Windows

信息的吞吐量主要决定于两个窗口：

**Receive Window（接收窗口）**
>Flow Control（流量控制）

主要用于控制不发送超过接收端处理能力的信息。即流量控制。

>**Nagel算法**

当发送端频繁发送小数据包时，此时接收端收到数据后，数据进入缓冲区，同时在应用程序读出这份数据时，接收端还需要向发送端发送一个窗口更新段来告知发送端，此时有更大的缓冲区可以用于数据接收了，即使这个缓冲区这是增大了一个字节而已，这种情况下会造成带宽的浪费。
Nagel算法提出延迟确认（**Delayed Acknowledgement**）来解决这一问题。如果发送端每次一很小量的数据包发送，则只发送第一个小数据包，而将后面的数据包缓冲起来，直到第一个小数据包被确认以后再将所有缓冲的数据添加到一个数据包中发送出去或者在缓冲区满后再发送。
而当TCP双方有很高的即使数据通讯要求时，这种延迟确认机制会增大消息的延迟，不适用于这种场景，通过可以使用**TCP_NODELAY**来禁用Nagel算法。

>**Silly Window Syndrome(低能窗口综合症)**

当接收端缓冲区已满且应用程序的读出速度很慢时，例如应用程序每次只读出一个字节，此时接收端需要发送一个窗口更新端，即使此时可用的窗口大小只有一个字节。这造成了极大的资源浪费。Clark解决方案限制了一个字节的窗口更新段，它强制接收端必须等待一段时间，直到有了一定数量的可用空间后再更新窗口大小到发送端。


**Congestion Window（拥塞控制窗口）**
>Congestion Control(拥塞控制)

拥塞窗口主要用于保证信息的发送接收不超过网络的承载能力。








