###问题###
>原架构

- 多进程，通过内存映射交换信息。（InvoiceFrame和InvoiceService）
- 信息触发通过时间片轮询。（InvoiceFrame 1s 计时器轮询映射内存）
- 接口业务处理与UI进程混合（InvoiceFrame）
- Json处理没有异常机制（jsoncpp第一版没有异常捕获）
- 字符编码不统一（Json、xml）
- 日志系统每次写入日志都执行文件IO操作

###讨论###
>计划修改

- 服务进程通过加载动态库进行业务接口数据分发
- UI和服务独立
- 第三方库选择更新版本
- 日志系统更新
- 通过单独的线程结合数据库记录进行全局的错误处理
- 增加网络设置（网络代理）
- 集中的错误处理
- 增加单元测试
- 将网络请求有函数封装更改为单独的类封装


###原因###
>**为什么做服务UI分离**

UI需要独立的线程做界面渲染

>**为什么去掉内存映射**

需要多个内核事件控制读写同步易出错，对于多条信息的映射后会造成混乱。

>**为什么使用SELECT模型而不用POLL或IOCP**

单线程SELECT模型天然可当队列使用，税控服务都是同步接口，不能并行调用。 POLL可以增加并发，当前本地服务不需要高并发。IOCP提高效率但需要自行实现队列。

>**为什么更换第三方解析库（JSON XML）以及统一字符编码**


更新的库有更好的效率同时具有更优秀的异常机制，需要明确JSON对于UTF-8编码有完全的支持，对于UNICODE则不然。同时编码的连续多次转换后不具有可逆性

>**为什么日志系统**


每次写入日志都进行IO操作有效率损失，不具有多线程安全性

>**为什么做全局的错误处理而不针对单个错误进行多线程重复上传**


全局的单线程错误处理更好管理，错误处理和恢复不需要即使性，结合数据库可以更好的控制错误处理的重试次数，重试间隔。

>**为什么增加单元测试**


提前发现问题。


>**为什么将网络请求有函数封装更改为单独的类封装**

函数封装后全局的网络请求都通过该函数实现网络请求，不具有可扩展性。对于该函数的修改会影响到全局的网络处理。



