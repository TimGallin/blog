##I/O##
>Input/Output指在[信息处理系统](https://en.wikipedia.org/wiki/Information_processing_system)之间的交流。

**Information Process System(信息处理系统)**
所谓信息处理系统就是指一种信息以后经过内部处理将其转化为另一种形式的信息的系统。例如计算机以及人类本身就是信息处理系统的一种，总之就是对于外界刺激做出特定反应的系统。

**Inputs**
系统收到的信息或信号统称为输入。
**Outputs**
系统发到的信息或信号统称为输入。
**I/O Devices**
由其他系统（包括人类）使用的硬件设备以完成与计算机交流的设备统称为I/O设备。

##Asynchronous I/O##
>异步I/O是一种允许其他过程在传输完成之前继续运行的I/O操作

同步I/O户阻塞处理器，这会浪费大量的处理器资源。例如一次磁盘操作可能需要10微秒，在这期间处理器将一直等待这次操作完成后再继续执行下一条指令，然后实际上在这端期间起码已经足够处理器完成一千万条指令了。
异步I/O可以在开始I/O操作后继续执行不依赖于本次I/O执行结果的指令，当使用异步I/O时，依赖于本地I/O过程将依然保持等待，但是其他过程得以继续执行。

异步I/O一般都在操作系统的底层实现，在上层只暴露出非常简单的API，这向用户隐藏了底层细节。异步I/O主要通过**[Polling](https://en.wikipedia.org/wiki/Polling_(computer_science))**机制。
例如，计算机对于打印机的操作使用（打印机一般通过并口连接，这让他可以一次性处理更多的数据），当我们需要打印一份文件时，计算机将数据发送到打印机，但是这些数据并不是一次性全部发送的，毕竟并口的数据传输和打印机的处理速度都是受限的，在同步I/O中，计算机发送数据后将等待打印机可以处理下一批数据知道全部处理完成，在这之间，计算机的处理器处理等待状态，这在单任务系统中运行的十分完美，但是在多任务多处理器的系统中，这是灾难性的资源浪费。而在异步I/O中，系统通过Polling机制，有效的避免了这一问题，所谓Polling，就是指系统会不停的询问打印机是否已经准备好接收数据了，这运用到了打印机本身的提供的驱动功能以及系统的硬件中断或[Direct memory access (DMA) ](https://en.wikipedia.org/wiki/Direct_memory_access) 技术，当打印机的状态是还未准备好时，计算机就会转而处理其他任务直到Polling下一次询问打印机的状态。
使用Polling机制也有缺点，那就是当有大量的设备需要被检测状态时，往往执行Polling的时间可能会超过执行设备I/O的时间，当然这些问题操作系统会帮用户处理平衡好。


|/|阻塞|非阻塞|
|--|--|--|
|同步|write,read|write,read+poll/select|
|异步|/|aio_write,aio_read,iocp|

##IOCP##
**Input/Output completion port (IO完成端口)**
>Windows系统I/O完成端口。这里的完成端口和系统的端口没有任何关系。


**OVERLAPPED**
>字面上有重叠的意思，这里指系统进行异步IO操作时执行IO操作的时间与线程执行其他任务的时间是重叠

在windows异步IO机制中，我们都需要在对应的函数调用中传入一个Overlapped的结构地址，当设备驱动执行完IO，系统将会通过事件或回调等方式通知用户，此时本次IO的操作结果将会保存在该Overlapped结构中。

**IOCP**
这里的**IOCP**是指由系统提供的一套完整的异步IO处理机制，目的是为了减少开发者对于异步IO复杂的代码处理逻辑以及线程管理。

```
IOCP的基本流程：

		创建IO完成端口（IOCP=CreateIoCompletionPort(Invalid Handle,...)）
			|
			|
		以异步的方式打开一个文件设备（通常是使用FILE_FLAG_OVERLAPPED参数调用CreateFile）
			|
			|
		将关联设备添加完成端口监听的队列（IOCP=CreateIoCompletionPort(hDevice,IOCP,CK_READ,...)）
			|
			|系统将hDevice添加到IOCP的监听队列
			|
		调用读取或写入（ReadFile(hDevice,...)）
			|
			|ReadFile函数会立刻返回，（由于FILE_FLAG_OVERLAPPED的原因），之后系统将该读取请求提交到设备的驱动程序执行
			|
		处理线程等待该完成端口（GetQueuedCompletionStatus(IOCP,...,CompletionKey=CK_READ)）,IO操作完成该函数将会退出
			|
			|设备驱动完成读取后将会通知系统，系统从等待线程中取出最后一个调用GetQueued...函数的线程并激活它（后入先出约定）
			|
		工作线程被激活开始进程处理

	//-----------------------------------------------------------------------------------
	//通过CompletionKey可以指定不同的监听事件，当系统唤醒工作线程时，线程可以通过这个参数来判断当前完成的异步IO操作是什么
	//并采取恰当的处理流程
```

**Windows IOCP 与线程池**
>IOCP 和 Thread Pool

IOCP本身设计的目的是只在一个进程中使用的，完成端口不能跨进程使用。传统的异步IO方案通常是提交IO操作后便创建一个线程等待IO操作的完成，之后再进行业务处理。试想在短时间内如果有多个IO请求，这将导致系统在短时间内创建大量活跃线程，这会将大量的资源浪费在多线程的上下文切换以及线程的创建和销毁上。而在接收IO请求之前就初始化一个线程池可以有效的减少不必要的资源浪费。

- 创建完成端口指定可允许并发运行的最大线程数：
通常指定为本机CPU的数量

- 线程池的初始容量:
通常设置为本机CPU数量的两倍。

   以上两个线程数量上限值存在明显的不合理，如果我们最大只允许等同CPU数量的线程并发运行，那为什么还要创建两倍于CPU数量的线程呢？要知道完成端口对于线程的管理遵循后入先出原则，即最后调用GetQueued...函数进程等待队列的线程将会被激活。
   缘由是完成端口对线程的智能管理。假设CPU的数量为2，我们创建了允许最多2条线程并发运行的完成端口并初始化了容量为4的线程池，当同时有3个已完成的IO请求被添加到端口队列中时，此时完成端口将唤醒两条线程对任务进行处理，基于2CPU的前提下，让一个任务继续等待而只激活两条线程进行任务处理有效的减少了线程上下文的切换的时间，最大化利用了多核CPU的并行能力。
   但是当此时其中一条工作线程调用了类似WaitForSingleObject函数的阻塞动作，此时线程将挂起，这会是CPU空闲造成资源浪费，IOCP的设计初衷就是最大化的利用CPU计算能力，基于IOCP的智能设计，此时完成端口将会检测到有一条工作线程处于挂起转态，并将这条线程从已释放（已唤醒）的队列中移除并将其加入已暂停线程队列，此时已释放队列的线程数量下降至1，完成端口将会激活第三条线程对下一个IO完成任务进行处理。

